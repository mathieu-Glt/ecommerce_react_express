import { createSlice } from "@reduxjs/toolkit";
import type { PayloadAction, Slice } from "@reduxjs/toolkit";
import {
  fetchProducts,
  searchProducts,
  fetchProductById,
  fetchLatestProducts,
  rateProduct,
  fetchProductsByCategoryId,
  fetchProductsBySubsCategoryId,
  fetchProductsByAverageRate,
} from "../thunks/productThunk";
import type { ProductState } from "../../interfaces/product.interface";
// import { loadProductStateFromLocalStorage } from "../middleware/localStorageMiddleware";

// ====================================================
// üîÑ HYDRATATION DEPUIS LOCAL STORAGE
// ====================================================

// const persistedProducts = loadProductStateFromLocalStorage();
// console.log("üåä [productSlice] √âtat persist√© charg√©:", persistedProducts);

// ====================================================
// üß† √âTAT INITIAL
// ====================================================

// const initialState: ProductState = persistedProducts || {
const initialState: ProductState = {
  products: [],
  selectedProduct: null,
  loading: false,
  error: null,
};

// ====================================================
// üß© SLICE PRODUITS
// ====================================================

const productSlice: Slice<ProductState> = createSlice({
  name: "products",
  initialState,

  // ----------------------------------------------------
  // üîπ Reducers synchrones
  // ----------------------------------------------------
  reducers: {
    /**
     * Vide compl√®tement la liste des produits
     * (utile lors du logout ou d‚Äôun refresh complet)
     */
    clearProducts: (state) => {
      state.products = [];
      state.selectedProduct = null;
      state.loading = false;
      state.error = null;
    },

    /**
     * D√©finit un produit s√©lectionn√© (ex: page d√©tail)
     */
    setSelectedProduct: (state, action: PayloadAction<any>) => {
      state.selectedProduct = action.payload;
    },

    /**
     * D√©finit manuellement une erreur
     */
    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload;
    },

    /**
     * D√©finit l‚Äô√©tat de chargement
     */
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },
  },

  // ----------------------------------------------------
  // üîπ Extra reducers ‚Äî Thunks async (API)
  // ----------------------------------------------------
  extraReducers: (builder) => {
    builder
      // ==========================================
      // FETCH PRODUCTS
      // ==========================================
      .addCase(fetchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        console.log("‚úÖ [productSlice] Produits r√©cup√©r√©s:", action.payload);

        state.loading = false;
        state.products = action.payload || [];
        state.error = null;
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        console.error(
          "‚ùå [productSlice] Erreur r√©cup√©ration produits:",
          action.payload
        );

        state.loading = false;
        state.error = (action.payload as string) || "Failed to fetch products";
      });
    // ==========================================
    // SEARCH PRODUCTS
    // ==========================================
    builder
      .addCase(searchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(searchProducts.fulfilled, (state, action) => {
        console.log("‚úÖ [productSlice] Produits recherch√©s:", action.payload);
        state.loading = false;
        state.products = action.payload.results || [];
        state.error = null;
      })
      .addCase(searchProducts.rejected, (state, action) => {
        console.error(
          "‚ùå [productSlice] Erreur recherche produits:",
          action.payload
        );
        state.loading = false;
        state.error = (action.payload as string) || "Failed to search products";
      });
    // ==========================================
    // GET PRODUCT BY ID
    // ==========================================
    builder
      .addCase(fetchProductById.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProductById.fulfilled, (state, action) => {
        console.log(
          "‚úÖ [productSlice] Produit par ID r√©cup√©r√©:",
          action.payload
        );
        state.loading = false;
        state.selectedProduct = action.payload || null;
        state.error = null;
      })
      .addCase(fetchProductById.rejected, (state, action) => {
        console.error(
          "‚ùå [productSlice] Erreur r√©cup√©ration produit par ID:",
          action.payload
        );
        state.loading = false;
        state.error =
          (action.payload as string) || "Failed to fetch product by ID";
      });
    // ==========================================
    // FECTH LATEST PRODUCTS
    // ==========================================
    builder
      .addCase(fetchLatestProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchLatestProducts.fulfilled, (state, action) => {
        console.log(
          "‚úÖ [productSlice] Derniers produits r√©cup√©r√©s:",
          action.payload
        );
        state.loading = false;
        state.products = action.payload || [];
        state.error = null;
      })
      .addCase(fetchLatestProducts.rejected, (state, action) => {
        console.error(
          "‚ùå [productSlice] Erreur r√©cup√©ration derniers produits:",
          action.payload
        );
        state.loading = false;
        state.error =
          (action.payload as string) || "Failed to fetch latest products";
      });
    // ==========================================
    // ‚≠ê RATE PRODUCT
    // ==========================================
    builder
      .addCase(rateProduct.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(rateProduct.fulfilled, (state, action) => {
        state.loading = false;
        const updatedProduct = action.payload;

        // Met √† jour le produit s√©lectionn√©
        if (
          state.selectedProduct &&
          state.selectedProduct._id === updatedProduct._id
        ) {
          state.selectedProduct = updatedProduct;
        }

        // Met √† jour la liste de produits si pr√©sente
        state.products = state.products.map((p) =>
          p._id === updatedProduct._id ? updatedProduct : p
        );
      })
      .addCase(rateProduct.rejected, (state, action) => {
        state.loading = false;
        state.error =
          (action.payload as string) || "Erreur lors de la notation du produit";
      });
    //=========================================
    // FETCH PRODUCTS BY CATEGORY ID
    // ==========================================
    builder
      .addCase(fetchProductsByCategoryId.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProductsByCategoryId.fulfilled, (state, action) => {
        console.log(
          "‚úÖ [productSlice] Produits par cat√©gorie r√©cup√©r√©s:",
          action.payload
        );
        state.loading = false;
        state.products = action.payload || [];
        state.error = null;
      })
      .addCase(fetchProductsByCategoryId.rejected, (state, action) => {
        console.error(
          "‚ùå [productSlice] Erreur r√©cup√©ration produits par cat√©gorie:",
          action.payload
        );
        state.loading = false;
        state.error =
          (action.payload as string) || "Failed to fetch products by category";
      });
    //=========================================
    // FETCH PRODUCTS BY SUBS CATEGORY ID
    // ==========================================
    builder
      .addCase(fetchProductsBySubsCategoryId.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProductsBySubsCategoryId.fulfilled, (state, action) => {
        console.log(
          "‚úÖ [productSlice] Produits par sous-cat√©gorie r√©cup√©r√©s:",
          action.payload
        );
        state.loading = false;
        state.products = action.payload || [];
        state.error = null;
      })
      .addCase(fetchProductsBySubsCategoryId.rejected, (state, action) => {
        console.error(
          "‚ùå [productSlice] Erreur r√©cup√©ration produits par sous-cat√©gorie:",
          action.payload
        );
        state.loading = false;
        state.error =
          (action.payload as string) ||
          "Failed to fetch products by subs category";
      });
    //=========================================
    // FETCH PRODUCTS BY AVERAGE RATE RATE MIN AND MAX
    // ==========================================
    builder
      .addCase(fetchProductsByAverageRate.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProductsByAverageRate.fulfilled, (state, action) => {
        console.log(
          "‚úÖ [productSlice] Produits par moyenne de notation r√©cup√©r√©s:",
          action.payload
        );
        state.loading = false;
        state.products = action.payload || [];
        state.error = null;
      })
      .addCase(fetchProductsByAverageRate.rejected, (state, action) => {
        console.error(
          "‚ùå [productSlice] Erreur r√©cup√©ration produits par moyenne de notation:",
          action.payload
        );
        state.loading = false;
        state.error =
          (action.payload as string) ||
          "Failed to fetch products by average rate";
      });
  },
});

// ====================================================
// üß≠ EXPORTS
// ====================================================

export const { clearProducts, setSelectedProduct, setError, setLoading } =
  productSlice.actions;

export default productSlice.reducer;
